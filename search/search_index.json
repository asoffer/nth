{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NTH A collection of libraries I find generally useful. Broadly speaking, nth aims at providing high-quality, highly-customizable libraries to be used across a broad number of applications. Some of these libraries are additive to the C++ standard library, while others are replacements/alternatives. Building from source nth is a collection of C++23 libraries, and relies heavily on Bazel for building and testing. You will need a C++23-compliant compiler and a relatively recent copy of Bazel . Specifically, Bazel version 6.3.2 or greater Clang 18.0.0 The nth libraries are intended to be used from your C++ code and always built from source. For this reason, we do not provide any installation or setup process. If you would like to download and play around with the examples, they can be built via these commands: $ git clone https://github.com/asoffer/nth.git $ cd nth $ bazel test ... If you would like to include nth in your own Bazel-based project, you can consume it as a Bazel module . I host a Bazel repository and update it somewhat regularly. You are of course always welcome to host your own Bazel repository pointing to the source on this github repository. Why is it called nth ? Mostly because I use a Dvorak keyboard layout, and those three characters in that order are particularly easy to type. It also has the accurate connotation that this is yet another kitchen sink utility library, but I didn't realize that until first mashing on the keyboard.","title":"Home"},{"location":"#nth","text":"A collection of libraries I find generally useful. Broadly speaking, nth aims at providing high-quality, highly-customizable libraries to be used across a broad number of applications. Some of these libraries are additive to the C++ standard library, while others are replacements/alternatives.","title":"NTH"},{"location":"#building-from-source","text":"nth is a collection of C++23 libraries, and relies heavily on Bazel for building and testing. You will need a C++23-compliant compiler and a relatively recent copy of Bazel . Specifically, Bazel version 6.3.2 or greater Clang 18.0.0 The nth libraries are intended to be used from your C++ code and always built from source. For this reason, we do not provide any installation or setup process. If you would like to download and play around with the examples, they can be built via these commands: $ git clone https://github.com/asoffer/nth.git $ cd nth $ bazel test ... If you would like to include nth in your own Bazel-based project, you can consume it as a Bazel module . I host a Bazel repository and update it somewhat regularly. You are of course always welcome to host your own Bazel repository pointing to the source on this github repository.","title":"Building from source"},{"location":"#why-is-it-called-nth","text":"Mostly because I use a Dvorak keyboard layout, and those three characters in that order are particularly easy to type. It also has the accurate connotation that this is yet another kitchen sink utility library, but I didn't realize that until first mashing on the keyboard.","title":"Why is it called nth?"},{"location":"base/attributes/","text":"//nth/base:attributes Overview Defines macros which wrap compiler-specific attributes and gives them a consistent API. One may query whether an attribute is supported via NTH_SUPPORTS_ATTRIBUTE(<attribute_name>) , and use the attribute via NTH_ATTRIBUTE(<attribute_name>) . A compilation error will be reported for any unsupported attribute. One may also use NTH_ATTRIBUTE_TRY(<attribute_name>) which will expand to the appropriate attribute if it is supported and nothing otherwise. Available attributes Note that not all of these attributes are available on all platforms. lifetimebound Defines an attribute consistent with the proposed wg21.link/p0936r0. When attached to a function parameter, indicates that the return value may reference the object bound to the attributed function parameter. weak Defines an attribute which may be used to mark symbol declarations and definitions as 'weak'. All unattributed symbols are implicitly declared strong. During linking, if any strong symbol of the same name exists all weak symbols will be ignored. Beyond this rule, the one-definition rule still applies: There must be either exactly one strong symbol definition, or no strong symbol definitions and one weak symbol definition. tailcall Defines an attribute indicating that the annotated return statement must be tail-call optimized. Use of this attribute is intended for situations where tail-call optimization is a requirement for correctness, rather than an optimization. As such, no fallback implementation is supported if the compiler does not support it. inline_always Defines an attribute indicating that the annotated function must be inlined by the compiler. Note that this attribute refers to how the compiler generates executable code, not the inline attribute in C++. inline_never Defines an attribute indicating that the annotated function must not be inlined by the compiler. Note that this attribute refers to how the compiler generates executable code, not the inline attribute in C++. trivial_abi Defines an attribute indicating that the annotated struct is trivial for the purposes of calls, indicating that it can be passed in registers.","title":"attributes"},{"location":"base/attributes/#nthbaseattributes","text":"","title":"//nth/base:attributes"},{"location":"base/attributes/#overview","text":"Defines macros which wrap compiler-specific attributes and gives them a consistent API. One may query whether an attribute is supported via NTH_SUPPORTS_ATTRIBUTE(<attribute_name>) , and use the attribute via NTH_ATTRIBUTE(<attribute_name>) . A compilation error will be reported for any unsupported attribute. One may also use NTH_ATTRIBUTE_TRY(<attribute_name>) which will expand to the appropriate attribute if it is supported and nothing otherwise.","title":"Overview"},{"location":"base/attributes/#available-attributes","text":"Note that not all of these attributes are available on all platforms.","title":"Available attributes"},{"location":"base/attributes/#lifetimebound","text":"Defines an attribute consistent with the proposed wg21.link/p0936r0. When attached to a function parameter, indicates that the return value may reference the object bound to the attributed function parameter.","title":"lifetimebound"},{"location":"base/attributes/#weak","text":"Defines an attribute which may be used to mark symbol declarations and definitions as 'weak'. All unattributed symbols are implicitly declared strong. During linking, if any strong symbol of the same name exists all weak symbols will be ignored. Beyond this rule, the one-definition rule still applies: There must be either exactly one strong symbol definition, or no strong symbol definitions and one weak symbol definition.","title":"weak"},{"location":"base/attributes/#tailcall","text":"Defines an attribute indicating that the annotated return statement must be tail-call optimized. Use of this attribute is intended for situations where tail-call optimization is a requirement for correctness, rather than an optimization. As such, no fallback implementation is supported if the compiler does not support it.","title":"tailcall"},{"location":"base/attributes/#inline_always","text":"Defines an attribute indicating that the annotated function must be inlined by the compiler. Note that this attribute refers to how the compiler generates executable code, not the inline attribute in C++.","title":"inline_always"},{"location":"base/attributes/#inline_never","text":"Defines an attribute indicating that the annotated function must not be inlined by the compiler. Note that this attribute refers to how the compiler generates executable code, not the inline attribute in C++.","title":"inline_never"},{"location":"base/attributes/#trivial_abi","text":"Defines an attribute indicating that the annotated struct is trivial for the purposes of calls, indicating that it can be passed in registers.","title":"trivial_abi"},{"location":"base/core/","text":"//nth/base:core Provides two macros NTH_MOVE and NTH_FWD which are replacements for std::move and std::forward respectively. In large code bases the extra cost of compiling these function templates and inlining them can have noticeable affect on compilation times. These macros are equivalent implementations removing that cost.","title":"core"},{"location":"base/core/#nthbasecore","text":"Provides two macros NTH_MOVE and NTH_FWD which are replacements for std::move and std::forward respectively. In large code bases the extra cost of compiling these function templates and inlining them can have noticeable affect on compilation times. These macros are equivalent implementations removing that cost.","title":"//nth/base:core"},{"location":"base/indestructible/","text":"//nth/base:indestructible An nth::indestructible<T> is a wrapper around an object of type T which does not invoke the destructor of T when it is destroyed. The primary motivation for such a type is for non-trivial static globals; such types frequently do not need to have their destructors run (as resources are returned to the operating system on exit). Moreover, running these destructors is typically fraught, if references to these object are held by multiple threads.","title":"indestructible"},{"location":"base/indestructible/#nthbaseindestructible","text":"An nth::indestructible<T> is a wrapper around an object of type T which does not invoke the destructor of T when it is destroyed. The primary motivation for such a type is for non-trivial static globals; such types frequently do not need to have their destructors run (as resources are returned to the operating system on exit). Moreover, running these destructors is typically fraught, if references to these object are held by multiple threads.","title":"//nth/base:indestructible"},{"location":"base/platform/","text":"//nth/base:platform Overview Provides a queryable interface to some build configuration information. NTH_ARCHITECTURE A function-like macro that expands to either true or false depending on whether the argument represents the target architecture. Valid arguments are arm64 , x64 , and unknown NTH_BUILD_FEATURE A function-like macro that expands to either true or false depending on whether the build feature is enabled. Valid arguments are: rtti : Indicates whether or not run-time type information is available. asan : Indicates whether or not address-sanitizer is enabled. tsan : Indicates whether or not thread-sanitizer is enabled. NTH_COMPILER A function-like macro that expands to either true or false depending on whether the argument represents the compiler. Valid arguments are clang , gcc , msvc , or unknown . NTH_EXECUTABLE_FORMAT A function-like macro that expands to either true or false depending on whether the argument represents the target executable format. Valid arguments are elf , macho , or unknown . NTH_OPERATING_SYSTEM A function-like macro that expands to either true or false depending on whether the argument represents the target operating system. Valid arguments are windows , apple , andriod , linux , or unknown .","title":"platform"},{"location":"base/platform/#nthbaseplatform","text":"","title":"//nth/base:platform"},{"location":"base/platform/#overview","text":"Provides a queryable interface to some build configuration information.","title":"Overview"},{"location":"base/platform/#nth_architecture","text":"A function-like macro that expands to either true or false depending on whether the argument represents the target architecture. Valid arguments are arm64 , x64 , and unknown","title":"NTH_ARCHITECTURE"},{"location":"base/platform/#nth_build_feature","text":"A function-like macro that expands to either true or false depending on whether the build feature is enabled. Valid arguments are: rtti : Indicates whether or not run-time type information is available. asan : Indicates whether or not address-sanitizer is enabled. tsan : Indicates whether or not thread-sanitizer is enabled.","title":"NTH_BUILD_FEATURE"},{"location":"base/platform/#nth_compiler","text":"A function-like macro that expands to either true or false depending on whether the argument represents the compiler. Valid arguments are clang , gcc , msvc , or unknown .","title":"NTH_COMPILER"},{"location":"base/platform/#nth_executable_format","text":"A function-like macro that expands to either true or false depending on whether the argument represents the target executable format. Valid arguments are elf , macho , or unknown .","title":"NTH_EXECUTABLE_FORMAT"},{"location":"base/platform/#nth_operating_system","text":"A function-like macro that expands to either true or false depending on whether the argument represents the target operating system. Valid arguments are windows , apple , andriod , linux , or unknown .","title":"NTH_OPERATING_SYSTEM"},{"location":"base/section/","text":"//nth/base:section Provides an API for defining sections in a binary and placing symbols in those sections. A section may be declared with NTH_DECLARE_SECTION(my_section_name, some_type) , indicating that the section is named \"my_section_name\" and that all elements in that section will have type some_type . Sections holding heterogeneously-typed objects are not supported. One may query this element-type of a section via nth::section_type<\"my_section_name\"> . Once a section has been declared, one may place objects in the section by prefixing their declaration with NTH_PLACE_IN_SECTION(my_section_name) . The expression nth::section<\"my_section_name\"> provides begin and end member functions and may be iterated over via a range-for loop.","title":"section"},{"location":"base/section/#nthbasesection","text":"Provides an API for defining sections in a binary and placing symbols in those sections. A section may be declared with NTH_DECLARE_SECTION(my_section_name, some_type) , indicating that the section is named \"my_section_name\" and that all elements in that section will have type some_type . Sections holding heterogeneously-typed objects are not supported. One may query this element-type of a section via nth::section_type<\"my_section_name\"> . Once a section has been declared, one may place objects in the section by prefixing their declaration with NTH_PLACE_IN_SECTION(my_section_name) . The expression nth::section<\"my_section_name\"> provides begin and end member functions and may be iterated over via a range-for loop.","title":"//nth/base:section"},{"location":"io/writer/file/","text":"//nth/io/writer:file Overview This target defines nth::io::file_writer , a type conforming to the nth::io::writer concept, which enables users to write data to a file. The type can be constructed with the static member function try_open , by passing it a nth::io::file_path , which will construct an empty file if it does not already exist, and clear the contents if it does. Calls to write will append to the open file. Example usage bool WriteMessage(nth::io::file_path const & path) { std::optional w = nth::io::file_writer::try_construct(path); if (not w) { return false; } std::string_view message = \"hello,\"; auto result = s.write(nth::byte_range(message)); return result.written() == message.size(); }","title":"file"},{"location":"io/writer/file/#nthiowriterfile","text":"","title":"//nth/io/writer:file"},{"location":"io/writer/file/#overview","text":"This target defines nth::io::file_writer , a type conforming to the nth::io::writer concept, which enables users to write data to a file. The type can be constructed with the static member function try_open , by passing it a nth::io::file_path , which will construct an empty file if it does not already exist, and clear the contents if it does. Calls to write will append to the open file.","title":"Overview"},{"location":"io/writer/file/#example-usage","text":"bool WriteMessage(nth::io::file_path const & path) { std::optional w = nth::io::file_writer::try_construct(path); if (not w) { return false; } std::string_view message = \"hello,\"; auto result = s.write(nth::byte_range(message)); return result.written() == message.size(); }","title":"Example usage"},{"location":"io/writer/string/","text":"//nth/io/writer:string Overview This target defines nth::io::string_writer , a type conforming to the nth::io::writer concept, which enables users to write data to a string. The type can be constructed with a mutable reference to a std::string . The referenced string must outlive the string_writer . Calls to write will append to the referenced string. Example usage std::string s; nth::io::string_writer w(s); std::string_view message1 = \"hello,\"; auto result1 = s.write(nth::byte_range(message1)); NTH_EXPECT(result1.written() == message1.size()); std::string_view message2 = \" world!\"; auto result2 = s.write(nth::byte_range(message1)); NTH_EXPECT(result2.written() == message2.size()); NTH_EXPECT(s == \"hello, world!\");","title":"string"},{"location":"io/writer/string/#nthiowriterstring","text":"","title":"//nth/io/writer:string"},{"location":"io/writer/string/#overview","text":"This target defines nth::io::string_writer , a type conforming to the nth::io::writer concept, which enables users to write data to a string. The type can be constructed with a mutable reference to a std::string . The referenced string must outlive the string_writer . Calls to write will append to the referenced string.","title":"Overview"},{"location":"io/writer/string/#example-usage","text":"std::string s; nth::io::string_writer w(s); std::string_view message1 = \"hello,\"; auto result1 = s.write(nth::byte_range(message1)); NTH_EXPECT(result1.written() == message1.size()); std::string_view message2 = \" world!\"; auto result2 = s.write(nth::byte_range(message1)); NTH_EXPECT(result2.written() == message2.size()); NTH_EXPECT(s == \"hello, world!\");","title":"Example usage"},{"location":"io/writer/writer/","text":"//nth/io/writer Overview This target defines concepts related to writing data in a serialized format. In particular, it defines the nth::io::writer and nth::io::write_result_type concepts. Writers are fundamental to much of nth 's design, including formatting and logging . As writers abstract the writing of both data (to be serialized) and text (to be logged). One might expect a writer to accept a std::string_view but this is fundamentally the wrong type for such a generic interface. Instead, a writer traffics in std::span<std::byte const> . One may produce a std::span<std::byte> viewing the bytes of an object via nth::bytes , or view a sequence of bytes represented by an object (such as std::string or std::string_view via nth::byte_range . Because writing data may not succeed, we must also represent the notion of a \"write result.\" This is formalized via the nth::io::write_result_type concept. The writer concept Formally, writer is a concept requiring the type W to contain a write member function that can be invoked with a std::span<std::byte const> . The function is responsible for writing the span of bytes in accordance with how the type W defines \"write.\" The function must return a nth::io::write_result<W> indicating how many bytes were written. For an argument byte_span producing a returned result of result , result.written() must be greater than or equal to zero, result.written() must be less than or equal to byte_span.size() . Callers may interpret result.written() == byte_span.size() as a successful write, result.written() == 0 as a failure, and all other possibilities as partial success. The write_result_type concept The type returned by a call to write on a writer must be something adhering to nth::io::write_result_type . Types adhere to this concept provided they have a written const member function taking no arguments and returning some integral type. The returned value represents the number of bytes written by a call to write . Write result customization. By default, a writer 's associated write result type is nth::io::basic_write_result . This is a minimal, type adhering to the write_result_type concept, outlined here: struct basic_write_result { explicit constexpr basic_write_result(size_t n); [[nodiscard]] constexpr size_t written() const; private: // ... }; Type authors may customize their associated write result type by providing a nested type name nth_write_result_type . This type must be adhere to the write_result_type concept and will be used as the associated write result type. One can query the write result for a writer type W via nth::io::write_result<W> . Examples There are two builtin nth::io::writers of note: nth::io::string_writer , for which calls to write append data to a std::string , and nth::io::file_writer , for which calls to write write the data to a file.","title":"writer"},{"location":"io/writer/writer/#nthiowriter","text":"","title":"//nth/io/writer"},{"location":"io/writer/writer/#overview","text":"This target defines concepts related to writing data in a serialized format. In particular, it defines the nth::io::writer and nth::io::write_result_type concepts. Writers are fundamental to much of nth 's design, including formatting and logging . As writers abstract the writing of both data (to be serialized) and text (to be logged). One might expect a writer to accept a std::string_view but this is fundamentally the wrong type for such a generic interface. Instead, a writer traffics in std::span<std::byte const> . One may produce a std::span<std::byte> viewing the bytes of an object via nth::bytes , or view a sequence of bytes represented by an object (such as std::string or std::string_view via nth::byte_range . Because writing data may not succeed, we must also represent the notion of a \"write result.\" This is formalized via the nth::io::write_result_type concept.","title":"Overview"},{"location":"io/writer/writer/#the-writer-concept","text":"Formally, writer is a concept requiring the type W to contain a write member function that can be invoked with a std::span<std::byte const> . The function is responsible for writing the span of bytes in accordance with how the type W defines \"write.\" The function must return a nth::io::write_result<W> indicating how many bytes were written. For an argument byte_span producing a returned result of result , result.written() must be greater than or equal to zero, result.written() must be less than or equal to byte_span.size() . Callers may interpret result.written() == byte_span.size() as a successful write, result.written() == 0 as a failure, and all other possibilities as partial success.","title":"The writer concept"},{"location":"io/writer/writer/#the-write_result_type-concept","text":"The type returned by a call to write on a writer must be something adhering to nth::io::write_result_type . Types adhere to this concept provided they have a written const member function taking no arguments and returning some integral type. The returned value represents the number of bytes written by a call to write .","title":"The write_result_type concept"},{"location":"io/writer/writer/#write-result-customization","text":"By default, a writer 's associated write result type is nth::io::basic_write_result . This is a minimal, type adhering to the write_result_type concept, outlined here: struct basic_write_result { explicit constexpr basic_write_result(size_t n); [[nodiscard]] constexpr size_t written() const; private: // ... }; Type authors may customize their associated write result type by providing a nested type name nth_write_result_type . This type must be adhere to the write_result_type concept and will be used as the associated write result type. One can query the write result for a writer type W via nth::io::write_result<W> .","title":"Write result customization."},{"location":"io/writer/writer/#examples","text":"There are two builtin nth::io::writers of note: nth::io::string_writer , for which calls to write append data to a std::string , and nth::io::file_writer , for which calls to write write the data to a file.","title":"Examples"}]}