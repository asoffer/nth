{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NTH A collection of libraries I find generally useful. Broadly speaking, nth aims at providing high-quality, highly-customizable libraries to be used across a broad number of applications. Some of these libraries are additive to the C++ standard library, while others are replacements/alternatives. Building from source nth is a collection of C++23 libraries, and relies heavily on Bazel for building and testing. You will need a C++23-compliant compiler and a relatively recent copy of Bazel . Specifically, Bazel version 6.3.2 or greater Clang 18.0.0 The nth libraries are intended to be used from your C++ code and always built from source. For this reason, we do not provide any installation or setup process. If you would like to download and play around with the examples, they can be built via these commands: $ git clone https://github.com/asoffer/nth.git $ cd nth $ bazel test ... If you would like to include nth in your own Bazel-based project, you can consume it as a Bazel module . I host a Bazel repository and update it somewhat regularly. You are of course always welcome to host your own Bazel repository pointing to the source on this github repository. Why is it called nth ? Mostly because I use a Dvorak keyboard layout, and those three characters in that order are particularly easy to type. It also has the accurate connotation that this is yet another kitchen sink utility library, but I didn't realize that until first mashing on the keyboard.","title":"Home"},{"location":"#nth","text":"A collection of libraries I find generally useful. Broadly speaking, nth aims at providing high-quality, highly-customizable libraries to be used across a broad number of applications. Some of these libraries are additive to the C++ standard library, while others are replacements/alternatives.","title":"NTH"},{"location":"#building-from-source","text":"nth is a collection of C++23 libraries, and relies heavily on Bazel for building and testing. You will need a C++23-compliant compiler and a relatively recent copy of Bazel . Specifically, Bazel version 6.3.2 or greater Clang 18.0.0 The nth libraries are intended to be used from your C++ code and always built from source. For this reason, we do not provide any installation or setup process. If you would like to download and play around with the examples, they can be built via these commands: $ git clone https://github.com/asoffer/nth.git $ cd nth $ bazel test ... If you would like to include nth in your own Bazel-based project, you can consume it as a Bazel module . I host a Bazel repository and update it somewhat regularly. You are of course always welcome to host your own Bazel repository pointing to the source on this github repository.","title":"Building from source"},{"location":"#why-is-it-called-nth","text":"Mostly because I use a Dvorak keyboard layout, and those three characters in that order are particularly easy to type. It also has the accurate connotation that this is yet another kitchen sink utility library, but I didn't realize that until first mashing on the keyboard.","title":"Why is it called nth?"},{"location":"base/attributes/","text":"//nth/base:attributes Overview Defines macros which wrap compiler-specific attributes and gives them a consistent API. One may query whether an attribute is supported via NTH_SUPPORTS_ATTRIBUTE(<attribute_name>) , and use the attribute via NTH_ATTRIBUTE(<attribute_name>) . A compilation error will be reported for any unsupported attribute. One may also use NTH_ATTRIBUTE_TRY(<attribute_name>) which will expand to the appropriate attribute if it is supported and nothing otherwise. Available attributes Note that not all of these attributes are available on all platforms. lifetimebound Defines an attribute consistent with the proposed wg21.link/p0936r0. When attached to a function parameter, indicates that the return value may reference the object bound to the attributed function parameter. weak Defines an attribute which may be used to mark symbol declarations and definitions as 'weak'. All unattributed symbols are implicitly declared strong. During linking, if any strong symbol of the same name exists all weak symbols will be ignored. Beyond this rule, the one-definition rule still applies: There must be either exactly one strong symbol definition, or no strong symbol definitions and one weak symbol definition. tailcall Defines an attribute indicating that the annotated return statement must be tail-call optimized. Use of this attribute is intended for situations where tail-call optimization is a requirement for correctness, rather than an optimization. As such, no fallback implementation is supported if the compiler does not support it. inline_always Defines an attribute indicating that the annotated function must be inlined by the compiler. Note that this attribute refers to how the compiler generates executable code, not the inline attribute in C++. inline_never Defines an attribute indicating that the annotated function must not be inlined by the compiler. Note that this attribute refers to how the compiler generates executable code, not the inline attribute in C++. trivial_abi Defines an attribute indicating that the annotated struct is trivial for the purposes of calls, indicating that it can be passed in registers.","title":"attributes"},{"location":"base/attributes/#nthbaseattributes","text":"","title":"//nth/base:attributes"},{"location":"base/attributes/#overview","text":"Defines macros which wrap compiler-specific attributes and gives them a consistent API. One may query whether an attribute is supported via NTH_SUPPORTS_ATTRIBUTE(<attribute_name>) , and use the attribute via NTH_ATTRIBUTE(<attribute_name>) . A compilation error will be reported for any unsupported attribute. One may also use NTH_ATTRIBUTE_TRY(<attribute_name>) which will expand to the appropriate attribute if it is supported and nothing otherwise.","title":"Overview"},{"location":"base/attributes/#available-attributes","text":"Note that not all of these attributes are available on all platforms.","title":"Available attributes"},{"location":"base/attributes/#lifetimebound","text":"Defines an attribute consistent with the proposed wg21.link/p0936r0. When attached to a function parameter, indicates that the return value may reference the object bound to the attributed function parameter.","title":"lifetimebound"},{"location":"base/attributes/#weak","text":"Defines an attribute which may be used to mark symbol declarations and definitions as 'weak'. All unattributed symbols are implicitly declared strong. During linking, if any strong symbol of the same name exists all weak symbols will be ignored. Beyond this rule, the one-definition rule still applies: There must be either exactly one strong symbol definition, or no strong symbol definitions and one weak symbol definition.","title":"weak"},{"location":"base/attributes/#tailcall","text":"Defines an attribute indicating that the annotated return statement must be tail-call optimized. Use of this attribute is intended for situations where tail-call optimization is a requirement for correctness, rather than an optimization. As such, no fallback implementation is supported if the compiler does not support it.","title":"tailcall"},{"location":"base/attributes/#inline_always","text":"Defines an attribute indicating that the annotated function must be inlined by the compiler. Note that this attribute refers to how the compiler generates executable code, not the inline attribute in C++.","title":"inline_always"},{"location":"base/attributes/#inline_never","text":"Defines an attribute indicating that the annotated function must not be inlined by the compiler. Note that this attribute refers to how the compiler generates executable code, not the inline attribute in C++.","title":"inline_never"},{"location":"base/attributes/#trivial_abi","text":"Defines an attribute indicating that the annotated struct is trivial for the purposes of calls, indicating that it can be passed in registers.","title":"trivial_abi"},{"location":"base/core/","text":"//nth/base:core Provides two macros NTH_MOVE and NTH_FWD which are replacements for std::move and std::forward respectively. In large code bases the extra cost of compiling these function templates and inlining them can have noticeable affect on compilation times. These macros are equivalent implementations removing that cost.","title":"core"},{"location":"base/core/#nthbasecore","text":"Provides two macros NTH_MOVE and NTH_FWD which are replacements for std::move and std::forward respectively. In large code bases the extra cost of compiling these function templates and inlining them can have noticeable affect on compilation times. These macros are equivalent implementations removing that cost.","title":"//nth/base:core"},{"location":"base/indestructible/","text":"//nth/base:indestructible An nth::indestructible<T> is a wrapper around an object of type T which does not invoke the destructor of T when it is destroyed. The primary motivation for such a type is for non-trivial static globals; such types frequently do not need to have their destructors run (as resources are returned to the operating system on exit). Moreover, running these destructors is typically fraught, if references to these object are held by multiple threads.","title":"indestructible"},{"location":"base/indestructible/#nthbaseindestructible","text":"An nth::indestructible<T> is a wrapper around an object of type T which does not invoke the destructor of T when it is destroyed. The primary motivation for such a type is for non-trivial static globals; such types frequently do not need to have their destructors run (as resources are returned to the operating system on exit). Moreover, running these destructors is typically fraught, if references to these object are held by multiple threads.","title":"//nth/base:indestructible"},{"location":"base/platform/","text":"//nth/base:platform Overview Provides a queryable interface to some build configuration information. NTH_ARCHITECTURE A function-like macro that expands to either true or false depending on whether the argument represents the target architecture. Valid arguments are arm64 , x64 , and unknown NTH_BUILD_FEATURE A function-like macro that expands to either true or false depending on whether the build feature is enabled. Valid arguments are: rtti : Indicates whether or not run-time type information is available. asan : Indicates whether or not address-sanitizer is enabled. tsan : Indicates whether or not thread-sanitizer is enabled. NTH_COMPILER A function-like macro that expands to either true or false depending on whether the argument represents the compiler. Valid arguments are clang , gcc , msvc , or unknown . NTH_EXECUTABLE_FORMAT A function-like macro that expands to either true or false depending on whether the argument represents the target executable format. Valid arguments are elf , macho , or unknown . NTH_OPERATING_SYSTEM A function-like macro that expands to either true or false depending on whether the argument represents the target operating system. Valid arguments are windows , apple , andriod , linux , or unknown .","title":"platform"},{"location":"base/platform/#nthbaseplatform","text":"","title":"//nth/base:platform"},{"location":"base/platform/#overview","text":"Provides a queryable interface to some build configuration information.","title":"Overview"},{"location":"base/platform/#nth_architecture","text":"A function-like macro that expands to either true or false depending on whether the argument represents the target architecture. Valid arguments are arm64 , x64 , and unknown","title":"NTH_ARCHITECTURE"},{"location":"base/platform/#nth_build_feature","text":"A function-like macro that expands to either true or false depending on whether the build feature is enabled. Valid arguments are: rtti : Indicates whether or not run-time type information is available. asan : Indicates whether or not address-sanitizer is enabled. tsan : Indicates whether or not thread-sanitizer is enabled.","title":"NTH_BUILD_FEATURE"},{"location":"base/platform/#nth_compiler","text":"A function-like macro that expands to either true or false depending on whether the argument represents the compiler. Valid arguments are clang , gcc , msvc , or unknown .","title":"NTH_COMPILER"},{"location":"base/platform/#nth_executable_format","text":"A function-like macro that expands to either true or false depending on whether the argument represents the target executable format. Valid arguments are elf , macho , or unknown .","title":"NTH_EXECUTABLE_FORMAT"},{"location":"base/platform/#nth_operating_system","text":"A function-like macro that expands to either true or false depending on whether the argument represents the target operating system. Valid arguments are windows , apple , andriod , linux , or unknown .","title":"NTH_OPERATING_SYSTEM"},{"location":"base/section/","text":"//nth/base:section Provides an API for defining sections in a binary and placing symbols in those sections. A section may be declared with NTH_DECLARE_SECTION(my_section_name, some_type) , indicating that the section is named \"my_section_name\" and that all elements in that section will have type some_type . Sections holding heterogeneously-typed objects are not supported. One may query this element-type of a section via nth::section_type<\"my_section_name\"> . Once a section has been declared, one may place objects in the section by prefixing their declaration with NTH_PLACE_IN_SECTION(my_section_name) . The expression nth::section<\"my_section_name\"> provides begin and end member functions and may be iterated over via a range-for loop.","title":"section"},{"location":"base/section/#nthbasesection","text":"Provides an API for defining sections in a binary and placing symbols in those sections. A section may be declared with NTH_DECLARE_SECTION(my_section_name, some_type) , indicating that the section is named \"my_section_name\" and that all elements in that section will have type some_type . Sections holding heterogeneously-typed objects are not supported. One may query this element-type of a section via nth::section_type<\"my_section_name\"> . Once a section has been declared, one may place objects in the section by prefixing their declaration with NTH_PLACE_IN_SECTION(my_section_name) . The expression nth::section<\"my_section_name\"> provides begin and end member functions and may be iterated over via a range-for loop.","title":"//nth/base:section"},{"location":"container/stack/","text":"//nth/container:stack Overview The container nth::stack represents a stack data structure. The nearest C++ Standard library equivalent structure is std::stack<T, std::vector<T>> (at least when T is not bool ), though nth::stack<T> will likely outperform std::stack<T, std::vector<T>> in most use cases. API push void push(T const&); void push(T &&); Pushes value onto the top of the stack. emplace template <typename... Args> void emplace(Args&&... args); Constructs a new element on the top of the stack equivalent to T(NTH_FWD(args)...) . pop void pop(); Removes an element from the stack. Behavior is undefined if the stack is empty. void pop(size_t n); Removes n elements from the stack. Behavior is undefined if the stack has fewer than n elements. top T& top(); T const& top() const; Returns a reference to the most-recently pushed element in the stack. Behavior is undefined if the stack is empty. top_span std::span<T> top_span(size_t n); std::span<T const> top_span(size_t n) const; template <size_t n> std::span<T, n> top_span(); std::span<T const, n> top_span() const; Returns a span over the top n elements of the stack. Behavior is undefined if the stack has fewer than n elements. release Note: This API is dangerous and should be used with care. It should only be used in conjuction with reconstitute_from as a mechanism to move a nth::stack<T> across a boundary that requires a trivial ABI. std::pair<T *, size_t> release() &&; Returns a pair constisting of a pointer to where the next element would be placed in the stacks internal buffer and the remaining capacity before a reallocation is required. The stack will be modified afterwards to be in a state suitable only for destruction or reassignment. reconstitute_from Note: This API is dangerous and should be used with care. It should only be used in conjuction with release as a mechanism to move a nth::stack<T> across a boundary that requires a trivial ABI. static reconstitute_from(T*, size_t); Constructs a nth::stack<T> from a pointer to where the next element should be pushed and the remaining capacity in the buffer. The buffer itself must adhere to all (undocumented) implementation requirements. The pair returned by release satisfies these requirements. swap void swap(stack& other); Replaces *this with other and vice versa. size size_t size() const; Returns the number of elements contained in the stack. empty bool empty() const; Returns true if the stack has no elements and false otherwise. remaining_capacity size_t remaining_capacity() const; Returns the number of elements that can be inserted before a reallocation is needed. capacity size_t capacity() const; Returns the number of elements that can be contained in the stack before a reallocation is needed. reserve void reserve(size_t n); Potentially reallocates to ensure that the capacity is sufficient to store at least n elements in total. Design Similar to std::vector<T> , all elements in nth::stack<T> are allocated in a single contiguous buffer and moved when the buffer needs to be reallocated to add more elements. nth::stack<T> stores two pieces of data in the struct itself: A pointer to one past the end of the stack, and the number of elements that could be pushed onto the stack before a reallocation is needed. This means that nth::stack<T> takes up only two words in comparison with std::vector<T> s three (in most implementations). This means that when pushing and popping, relatively less work needs to be done in comparison with std::vector<T> . When pushing an element (if reallocation is not needed), A single placement-new is required, followed by incrementing the pointer and decrementing the remaining capacity. When the remaining capacity reaches zero and a reallocation becomes necessary, the structure must be able to compute the size of the allocated buffer. Whereas std::vector<T> either stores this or has a fast pointer computation to compute it, nth::stack<T> may be slower (only during this reallocation). In an nth::stack , the overall buffer size is stored in the buffer itself at the very end. The benefits of this approach is that the buffer size, which is only necessary to read/write during reallocation, is typically not held in cache, but will often be pulled into cache on the same cache line as the last element pushed onto the stack.","title":"stack"},{"location":"container/stack/#nthcontainerstack","text":"","title":"//nth/container:stack"},{"location":"container/stack/#overview","text":"The container nth::stack represents a stack data structure. The nearest C++ Standard library equivalent structure is std::stack<T, std::vector<T>> (at least when T is not bool ), though nth::stack<T> will likely outperform std::stack<T, std::vector<T>> in most use cases.","title":"Overview"},{"location":"container/stack/#api","text":"","title":"API"},{"location":"container/stack/#push","text":"void push(T const&); void push(T &&); Pushes value onto the top of the stack.","title":"push"},{"location":"container/stack/#emplace","text":"template <typename... Args> void emplace(Args&&... args); Constructs a new element on the top of the stack equivalent to T(NTH_FWD(args)...) .","title":"emplace"},{"location":"container/stack/#pop","text":"void pop(); Removes an element from the stack. Behavior is undefined if the stack is empty. void pop(size_t n); Removes n elements from the stack. Behavior is undefined if the stack has fewer than n elements.","title":"pop"},{"location":"container/stack/#top","text":"T& top(); T const& top() const; Returns a reference to the most-recently pushed element in the stack. Behavior is undefined if the stack is empty.","title":"top"},{"location":"container/stack/#top_span","text":"std::span<T> top_span(size_t n); std::span<T const> top_span(size_t n) const; template <size_t n> std::span<T, n> top_span(); std::span<T const, n> top_span() const; Returns a span over the top n elements of the stack. Behavior is undefined if the stack has fewer than n elements.","title":"top_span"},{"location":"container/stack/#release","text":"Note: This API is dangerous and should be used with care. It should only be used in conjuction with reconstitute_from as a mechanism to move a nth::stack<T> across a boundary that requires a trivial ABI. std::pair<T *, size_t> release() &&; Returns a pair constisting of a pointer to where the next element would be placed in the stacks internal buffer and the remaining capacity before a reallocation is required. The stack will be modified afterwards to be in a state suitable only for destruction or reassignment.","title":"release"},{"location":"container/stack/#reconstitute_from","text":"Note: This API is dangerous and should be used with care. It should only be used in conjuction with release as a mechanism to move a nth::stack<T> across a boundary that requires a trivial ABI. static reconstitute_from(T*, size_t); Constructs a nth::stack<T> from a pointer to where the next element should be pushed and the remaining capacity in the buffer. The buffer itself must adhere to all (undocumented) implementation requirements. The pair returned by release satisfies these requirements.","title":"reconstitute_from"},{"location":"container/stack/#swap","text":"void swap(stack& other); Replaces *this with other and vice versa.","title":"swap"},{"location":"container/stack/#size","text":"size_t size() const; Returns the number of elements contained in the stack.","title":"size"},{"location":"container/stack/#empty","text":"bool empty() const; Returns true if the stack has no elements and false otherwise.","title":"empty"},{"location":"container/stack/#remaining_capacity","text":"size_t remaining_capacity() const; Returns the number of elements that can be inserted before a reallocation is needed.","title":"remaining_capacity"},{"location":"container/stack/#capacity","text":"size_t capacity() const; Returns the number of elements that can be contained in the stack before a reallocation is needed.","title":"capacity"},{"location":"container/stack/#reserve","text":"void reserve(size_t n); Potentially reallocates to ensure that the capacity is sufficient to store at least n elements in total.","title":"reserve"},{"location":"container/stack/#design","text":"Similar to std::vector<T> , all elements in nth::stack<T> are allocated in a single contiguous buffer and moved when the buffer needs to be reallocated to add more elements. nth::stack<T> stores two pieces of data in the struct itself: A pointer to one past the end of the stack, and the number of elements that could be pushed onto the stack before a reallocation is needed. This means that nth::stack<T> takes up only two words in comparison with std::vector<T> s three (in most implementations). This means that when pushing and popping, relatively less work needs to be done in comparison with std::vector<T> . When pushing an element (if reallocation is not needed), A single placement-new is required, followed by incrementing the pointer and decrementing the remaining capacity. When the remaining capacity reaches zero and a reallocation becomes necessary, the structure must be able to compute the size of the allocated buffer. Whereas std::vector<T> either stores this or has a fast pointer computation to compute it, nth::stack<T> may be slower (only during this reallocation). In an nth::stack , the overall buffer size is stored in the buffer itself at the very end. The benefits of this approach is that the buffer size, which is only necessary to read/write during reallocation, is typically not held in cache, but will often be pulled into cache on the same cache line as the last element pushed onto the stack.","title":"Design"},{"location":"debug/log/","text":"//nth/debug/log Overview This target defines a macro NTH_LOG used for debug logging, and a few free functions controlling its behavior. Logging is built on top of the interpolation library . In its simplest usage, one would provide an interpolation as an argument to the NTH_LOG macro whose placeholders will be filled in with logging arguments. NTH_LOG(\"The first three primes are {}, {}, and {}\") <<= {2, 3, 5}; Log macros also can accept an optional first argument; a parethesized path-like string-literal which we call the verbosity path . The verbosity path is simply an identifier that gives us a mechanism to dynamically enable or disable log statements. NTH_LOG((\"my/verbosity/path\"), \"What roll's down {}, alone or in {}?\") <<= {\"stairs\", \"pairs\"}; Sometimes log statements do not require any interpolaction arguments, in which case, one can simply elide the trailing <<= {} , as in: NTH_LOG((\"my/verbosity/path\"), \"It's log! It's log! It's big, it's heavy, it's wood!\"); Verbosity Logs can be enabled or disabled by speficying globs. nth::log_verbosity_off : Accepts a glob and disables all enabled log statements whose verbosity path matches the glob. nth::log_verbosity_on : Accepts a glob and enables all disabled log statements whose verbosity path matches the glob. nth::log_verbosity_if : Accepts a glob and enables all log statements whose verbosity path mtaches the glob and disables all others. Dynamically changing the verbosity of log statements can be expensive, because it requires matching a glob against every log statement in the binary. Changing verbosity should be rare. Log sinks Log sinks are globally registered objects inheriting from nth::log_sink which process objects of type nth::log_entry . Log sinks are registered via the nth::register_log_sink free function and cannot be unregistered. When a log line is evaluated, if the log is enabled, it will construct a nth::log_entry and pass it to every registered log sink.","title":"log"},{"location":"debug/log/#nthdebuglog","text":"","title":"//nth/debug/log"},{"location":"debug/log/#overview","text":"This target defines a macro NTH_LOG used for debug logging, and a few free functions controlling its behavior. Logging is built on top of the interpolation library . In its simplest usage, one would provide an interpolation as an argument to the NTH_LOG macro whose placeholders will be filled in with logging arguments. NTH_LOG(\"The first three primes are {}, {}, and {}\") <<= {2, 3, 5}; Log macros also can accept an optional first argument; a parethesized path-like string-literal which we call the verbosity path . The verbosity path is simply an identifier that gives us a mechanism to dynamically enable or disable log statements. NTH_LOG((\"my/verbosity/path\"), \"What roll's down {}, alone or in {}?\") <<= {\"stairs\", \"pairs\"}; Sometimes log statements do not require any interpolaction arguments, in which case, one can simply elide the trailing <<= {} , as in: NTH_LOG((\"my/verbosity/path\"), \"It's log! It's log! It's big, it's heavy, it's wood!\");","title":"Overview"},{"location":"debug/log/#verbosity","text":"Logs can be enabled or disabled by speficying globs. nth::log_verbosity_off : Accepts a glob and disables all enabled log statements whose verbosity path matches the glob. nth::log_verbosity_on : Accepts a glob and enables all disabled log statements whose verbosity path matches the glob. nth::log_verbosity_if : Accepts a glob and enables all log statements whose verbosity path mtaches the glob and disables all others. Dynamically changing the verbosity of log statements can be expensive, because it requires matching a glob against every log statement in the binary. Changing verbosity should be rare.","title":"Verbosity"},{"location":"debug/log/#log-sinks","text":"Log sinks are globally registered objects inheriting from nth::log_sink which process objects of type nth::log_entry . Log sinks are registered via the nth::register_log_sink free function and cannot be unregistered. When a log line is evaluated, if the log is enabled, it will construct a nth::log_entry and pass it to every registered log sink.","title":"Log sinks"},{"location":"debug/unimplemented/","text":"//nth/debug:unimplemented This target defines the macro NTH_UNIMPLEMENTED . Invocations of this macro indicate that the author intends this to be a valid code path that they have not yet implemented. Invocation of this macro will always abort, after potentially logging. if NTH_UNIMPLEMENTED is invoked with no arguments, a simple default message will be logged. Users may also provide an interpolation string and inject extra information that will be appended to the log message, as if NTH_UNREACHABLE were NTH_LOG . That is, one could write enum suit { clubs, diamonds, hearts, spades }; void handle_suit(suit s) { switch (s) { case clubs: return HandleClubs(); case diamonds: return HandleDiamonds(); case hearts: [[fallthrough]]; case spades: NTH_UNIMPLEMENTED(\"Suit {} has not yet been implemented.\") <<= {s}; } }","title":"unimplemented"},{"location":"debug/unimplemented/#nthdebugunimplemented","text":"This target defines the macro NTH_UNIMPLEMENTED . Invocations of this macro indicate that the author intends this to be a valid code path that they have not yet implemented. Invocation of this macro will always abort, after potentially logging. if NTH_UNIMPLEMENTED is invoked with no arguments, a simple default message will be logged. Users may also provide an interpolation string and inject extra information that will be appended to the log message, as if NTH_UNREACHABLE were NTH_LOG . That is, one could write enum suit { clubs, diamonds, hearts, spades }; void handle_suit(suit s) { switch (s) { case clubs: return HandleClubs(); case diamonds: return HandleDiamonds(); case hearts: [[fallthrough]]; case spades: NTH_UNIMPLEMENTED(\"Suit {} has not yet been implemented.\") <<= {s}; } }","title":"//nth/debug:unimplemented"},{"location":"debug/unreachable/","text":"//nth/debug:unreachable This target defines the macro NTH_UNREACHABLE . Invocations of this macro are always bugs, as this code path indicates that the programmer believed this code path could never be reached in a valid program. In debug builds, invocation of NTH_UNREACHABLE will log an error message and then abort execution. Users may also provide an interpolation string and inject extra information that will be appended to the log message, as if NTH_UNREACHABLE were NTH_LOG . That is, one could write switch (n) { case 0: return DoCase0(); case 1: return DoCase1(); case 2: return DoCase2(); default: NTH_UNREACHABLE(\"We should never have n = {}\") <<= {n}; } In optimized builds, invocation of NTH_UNREACHABLE is undefined, allowing compilers to optimize under the assumption that this code path is never reached.","title":"unreachable"},{"location":"debug/unreachable/#nthdebugunreachable","text":"This target defines the macro NTH_UNREACHABLE . Invocations of this macro are always bugs, as this code path indicates that the programmer believed this code path could never be reached in a valid program. In debug builds, invocation of NTH_UNREACHABLE will log an error message and then abort execution. Users may also provide an interpolation string and inject extra information that will be appended to the log message, as if NTH_UNREACHABLE were NTH_LOG . That is, one could write switch (n) { case 0: return DoCase0(); case 1: return DoCase1(); case 2: return DoCase2(); default: NTH_UNREACHABLE(\"We should never have n = {}\") <<= {n}; } In optimized builds, invocation of NTH_UNREACHABLE is undefined, allowing compilers to optimize under the assumption that this code path is never reached.","title":"//nth/debug:unreachable"},{"location":"format/cc/","text":"//nth/format:cc This target provides a structural formatter that writes objects as valid C++ initializing expressions.","title":"cc"},{"location":"format/cc/#nthformatcc","text":"This target provides a structural formatter that writes objects as valid C++ initializing expressions.","title":"//nth/format:cc"},{"location":"format/format/","text":"//nth/format Overview The formatting library is a layer on top of //nth/io/writer responsible for marhsalling data of arbitrary types into a writer. The primary workhorse is the nth::format function template, which accepts a nth::io::writer , a formatter, and an object to be formatted. There is also a two-parameter overload for nth::format , which uses nth::default_formatter<T> as its formatter. nth::format The nth::format function template accepts a reference to a writer w , a reference to a formatter fmt , and a const-reference to a value v to be formatted. If fmt.format(w, value) is a valid expression, this is what nth::format(w, fmt, v) evaluates to. Otherwise, it will evaulate to NthFormat(w, fmt, value) , where NthFormat is the FTADLE hook. As an example, consider a Person struct and suppose we would like to implement a function that returns a greeting string. To do this we would implement NthFormat for the Person struct. struct Person { std::string name; friend void NthFormat(nth::io::writer auto& w, auto& fmt, Person const& p) { nth::format(w, fmt, p.name); } }; std::string greeting_string(Person const & person) { std::string s; nth::io::string_writer w(s); nth::io::write_text(w, \"Hello, \"); nth::format(w, person); nth::io::write_text(w, \"!\"); return s; } Note in this example nth::format(w, person) uses the default formatter for Person (because the two-parameter nth::format is invoked). The default formatter for person is nth::trivial_formatter (more on how to customize this below), which does not have a format member function, so NthFormat(w, fmt, p) is invoked. This in turn invokes nth::format(w, fmt, p.name) . This process continues recursively, now with the same writer, an nth::trivial_formatter for the formatter, and p.name of type std::string . Because the library provides a FTADLE hook for std::string , this resolves by writing the string to the writer. Custom default formatters By default, the default formatter for a type is nth::trivial_formatter , but users may configure the default formatter (the one used when no formatter argument is provided to nth::format ) with a FTADLE hook. In particular, users can implement a function named NthDefaultFormatter accepting an nth::type_tag<T> . Note that this function can also be a hidden friend inside the body of the type T , as this will still be findable via argument-dependent lookup. As an example, one might want a formatter fora person to distinguish whether or not their name should be capitalized. One could add the following to make the default capitaziled: struct PersonFormatter { bool capitalized; void format(nth::io::writer auto& w, Person const& p) const { if (p.name.empty()) { return; } if (capitalized) { nth::io::write_text(w, capitalize(p.name[0])); nth::io::write_text(w, p.name.substr(1)); } else { nth::io::write_text(w, p.name); } } }; struct Person { std::string name; friend PersonFormatter NthDefaultFormatter(nth::type_tag<Person>) { return PersonFormatter{.capitalized = true}; } friend void NthFormat(nth::io::writer auto& w, auto& fmt, Person const& p) { nth::format(w, fmt, p.name); } }; Now, when a person is formatted, the name will be capitalized by default, though one could pass a different PersonFormatter to achieve a different result. Structured Formatting A common formatting pattern is to effectively format all of the content in a struct, sequence, or container, possibly with some surrounding decaration. The nth::structural_formatter type can be used to simplify this process. To use the nth::structural_formatter type, users must inherit from it and provide several customization points. The first such hook is a static variable template of type nth::structure named structure_of , as shown in the example below: struct my_formatter : nth::structural_formatter { template <typename T> static constexpr nth::structure structure_of = ... ... }; The base class will use structure_of to understand the structure of each to-be-formatted type and do the formatting accordingly. Users may also implement, for each enumerator S in nth::structure , a member function template in their formatter with signatures begin(nth::constant_value<S>, nth::io::writer auto& w) and end(nth::constant_value<S>, nth::io::writer auto& w) , to be called immediately before and after (respectively) an object of that structural category is formatted. This allows one to, for instance, wrap sequences in \"[...]\" , or associative containers in \"{...}\" . Note that if you implement begin for a structural category, you must also implement end (even if it is empty), and vice versa. Failing to do so will result in a compilation error with an error message explaining the mistake. This is an intentional design choice. Due to the nature of the design, it is easy to accidentally forget or misspell one of these function templates and silently leave off such a function. While we would hope that unit tests would catch such problems, enforcing that users must provide both or neither yields slightly more assurance of correctness. Sequences When sequences are formatted via nth::structural_formatter , the following will occur. nth::begin_format<nth::structure::sequence>(w, fmt); for (auto const& element : seq) { nth::begin_format<nth::structure::entry>(w, fmt); nth::format(w, fmt, element); nth::end_format<nth::structure::entry>(w, fmt); } nth::end_format<nth::structure::sequence>(w, fmt); Associative containers When associative containers are formatted via nth::structural_formatter , the following will occur. nth::begin_format<nth::structure::associative>(w, fmt); for (auto const& [k, v] : associative_container) { nth::begin_format<nth::structure::key>(w, fmt); nth::format(w, fmt, k); nth::end_format<nth::structure::key>(w, fmt); nth::begin_format<nth::structure::value>(w, fmt); nth::format(w, fmt, v); nth::end_format<nth::structure::value>(w, fmt); } nth::end_format<nth::structure::associative>(w, fmt); Objects There is no provided builtin mechanism for formatting objects.","title":"format"},{"location":"format/format/#nthformat","text":"","title":"//nth/format"},{"location":"format/format/#overview","text":"The formatting library is a layer on top of //nth/io/writer responsible for marhsalling data of arbitrary types into a writer. The primary workhorse is the nth::format function template, which accepts a nth::io::writer , a formatter, and an object to be formatted. There is also a two-parameter overload for nth::format , which uses nth::default_formatter<T> as its formatter.","title":"Overview"},{"location":"format/format/#nthformat_1","text":"The nth::format function template accepts a reference to a writer w , a reference to a formatter fmt , and a const-reference to a value v to be formatted. If fmt.format(w, value) is a valid expression, this is what nth::format(w, fmt, v) evaluates to. Otherwise, it will evaulate to NthFormat(w, fmt, value) , where NthFormat is the FTADLE hook. As an example, consider a Person struct and suppose we would like to implement a function that returns a greeting string. To do this we would implement NthFormat for the Person struct. struct Person { std::string name; friend void NthFormat(nth::io::writer auto& w, auto& fmt, Person const& p) { nth::format(w, fmt, p.name); } }; std::string greeting_string(Person const & person) { std::string s; nth::io::string_writer w(s); nth::io::write_text(w, \"Hello, \"); nth::format(w, person); nth::io::write_text(w, \"!\"); return s; } Note in this example nth::format(w, person) uses the default formatter for Person (because the two-parameter nth::format is invoked). The default formatter for person is nth::trivial_formatter (more on how to customize this below), which does not have a format member function, so NthFormat(w, fmt, p) is invoked. This in turn invokes nth::format(w, fmt, p.name) . This process continues recursively, now with the same writer, an nth::trivial_formatter for the formatter, and p.name of type std::string . Because the library provides a FTADLE hook for std::string , this resolves by writing the string to the writer.","title":"nth::format"},{"location":"format/format/#custom-default-formatters","text":"By default, the default formatter for a type is nth::trivial_formatter , but users may configure the default formatter (the one used when no formatter argument is provided to nth::format ) with a FTADLE hook. In particular, users can implement a function named NthDefaultFormatter accepting an nth::type_tag<T> . Note that this function can also be a hidden friend inside the body of the type T , as this will still be findable via argument-dependent lookup. As an example, one might want a formatter fora person to distinguish whether or not their name should be capitalized. One could add the following to make the default capitaziled: struct PersonFormatter { bool capitalized; void format(nth::io::writer auto& w, Person const& p) const { if (p.name.empty()) { return; } if (capitalized) { nth::io::write_text(w, capitalize(p.name[0])); nth::io::write_text(w, p.name.substr(1)); } else { nth::io::write_text(w, p.name); } } }; struct Person { std::string name; friend PersonFormatter NthDefaultFormatter(nth::type_tag<Person>) { return PersonFormatter{.capitalized = true}; } friend void NthFormat(nth::io::writer auto& w, auto& fmt, Person const& p) { nth::format(w, fmt, p.name); } }; Now, when a person is formatted, the name will be capitalized by default, though one could pass a different PersonFormatter to achieve a different result.","title":"Custom default formatters"},{"location":"format/format/#structured-formatting","text":"A common formatting pattern is to effectively format all of the content in a struct, sequence, or container, possibly with some surrounding decaration. The nth::structural_formatter type can be used to simplify this process. To use the nth::structural_formatter type, users must inherit from it and provide several customization points. The first such hook is a static variable template of type nth::structure named structure_of , as shown in the example below: struct my_formatter : nth::structural_formatter { template <typename T> static constexpr nth::structure structure_of = ... ... }; The base class will use structure_of to understand the structure of each to-be-formatted type and do the formatting accordingly. Users may also implement, for each enumerator S in nth::structure , a member function template in their formatter with signatures begin(nth::constant_value<S>, nth::io::writer auto& w) and end(nth::constant_value<S>, nth::io::writer auto& w) , to be called immediately before and after (respectively) an object of that structural category is formatted. This allows one to, for instance, wrap sequences in \"[...]\" , or associative containers in \"{...}\" . Note that if you implement begin for a structural category, you must also implement end (even if it is empty), and vice versa. Failing to do so will result in a compilation error with an error message explaining the mistake. This is an intentional design choice. Due to the nature of the design, it is easy to accidentally forget or misspell one of these function templates and silently leave off such a function. While we would hope that unit tests would catch such problems, enforcing that users must provide both or neither yields slightly more assurance of correctness.","title":"Structured Formatting"},{"location":"format/format/#sequences","text":"When sequences are formatted via nth::structural_formatter , the following will occur. nth::begin_format<nth::structure::sequence>(w, fmt); for (auto const& element : seq) { nth::begin_format<nth::structure::entry>(w, fmt); nth::format(w, fmt, element); nth::end_format<nth::structure::entry>(w, fmt); } nth::end_format<nth::structure::sequence>(w, fmt);","title":"Sequences"},{"location":"format/format/#associative-containers","text":"When associative containers are formatted via nth::structural_formatter , the following will occur. nth::begin_format<nth::structure::associative>(w, fmt); for (auto const& [k, v] : associative_container) { nth::begin_format<nth::structure::key>(w, fmt); nth::format(w, fmt, k); nth::end_format<nth::structure::key>(w, fmt); nth::begin_format<nth::structure::value>(w, fmt); nth::format(w, fmt, v); nth::end_format<nth::structure::value>(w, fmt); } nth::end_format<nth::structure::associative>(w, fmt);","title":"Associative containers"},{"location":"format/format/#objects","text":"There is no provided builtin mechanism for formatting objects.","title":"Objects"},{"location":"format/interpolate/","text":"//nth/format:interpolate Overview This target provides added functionality on top of //nth/format by making it possible to specify formatters via interpolation strings . Interpolation strings, as used in the nth library, are strings with some number of matching braces \"{...}\" . Each top-level (non-nested) pair of matching braces constitutes a placeholder into which a value may be formatted. The end result of interpolating will be the interpolation string itself with each placeholder replaced by some formatted object. Basics The core of the library is the free function-template nth::interpolate . It accepts an nth::interpolation_string template parameter, an nth::io::writer reference, and a number of arguments equal to the number of pairs of matching braces. nth::interpolate<\"'{}' is the Roman numeral symbol for {}.\">( nth::io::stdout_writer, \"IX\", 9); // \"'IX' is the Roman numeral symbol for 9.\" In the example above, the placeholders are simply \"{}\" , but some types support configuration by putting text inside the braces. For example, integers can have an 'x' inside to indicate they should be formatted in base-16. Strings can have a 'q' to indicate that they should be escaped as a quotation. nth::interpolate<\"{} can be written is base-16 as {x}.\">( nth::io::stdout_writer, 17, 17); // 17 can be written is base-16 as 11.\" Builtin format options The following are the interpolation arguments available for builtin types: bool {} and {b}: Lower-case. Writes either \"true\" or \"false\"`. { B} : Title-case. Writes either \"True\" or \"False\"`. { B !} : Upper-case. Writes either \"TRUE\" or \"FALSE\"`. { d} : Decimal. Writes either \"1\" or \"0\"`. Integral types Integral types are anything satisfying the std::integral concept (other than bool ). { d} : Decimal. Writes the number in base-10. { x} : Hexadecimal. Writes the number in base-16. String-like String-like types are anything convertible to std::string_view . {} : Writes the string exactly as-is. { q} : Escaped. Writes the string escaping characters such as \" , and \\ . Custom interpolation formatting. By default, the empty interpolation placeholder \"{}\" will format an object with that objects default formatter . However, this behavior is customizable via a FTADLE hook. Specifically, an author of a type T may implement a function template accepting an nth::interpolation_string template argument and an nth::type_tag<T> argument. The function, if provided, will be called with the contents that are between the braces to construct a formatter to be used during interpolation. As an example, struct Person { std::string given_name; std::string family_name; template <nth::interpolation_string S> friend auto NthInterpolateFormatter(nth::type_tag<Person>) { if constexpr (S.empty()) { return full_name_formatter{}; } else if constexpr (S == \"g\") { return given_name_formatter{}; } else if constexpr (S == \"f\") { return family_name_formatter{}; } else { // Checked previously so guaranteed to be false (but dependent on the // template parameter. constexpr bool ValidInterpolationString = S.empty(); static_assert(ValidInterpolationString, \"The interpolation string is invalid. It must be \"{}\", \"{ g}\", or \"{ f}\".); } } }; Now, depending on the interpolation string, a person will be formatted with a full_name_formatter , a given_name_formatter or a family_name_formatter . One might implement those as shown below: struct full_name_formatter { void format(nth::io::writer auto& w, Person const & p) { nth::interpolate<\"{} {}\">(w, p.given_name, p.family_name); } }; struct given_name_formatter { void format(nth::io::writer auto& w, Person const& p) { nth::io::write_text(w, p.given_name); } }; struct family_name_formatter { void format(nth::io::writer auto& w, Person const& p) { nth::io::write_text(w, p.family_name); } }; Escaping TODO: Escaping has not yet been implemented. At times one may wish for the interpolation string to have a literal '{' character embedded in it which is not treated as the start of a placeholder. To achieve this, one must escape the character by prefixing it with a '`' (and similarly suffixing '}' with '`' ). If one wishes to have a literal backtick character, this also needs to be escaped as \"``\" in the interpolation string. When parsing an interpolation string, the \"max munch\" rule applies except for escaped closing braces (because the escape character follows the character to be escaped). In this case escape tokenization can be thought of as \"max much from the right.\" Alternatively, one could count the number of backtics following the '}' character. The '}' is escaped if and only if there are an odd number of backticks.","title":"interpolate"},{"location":"format/interpolate/#nthformatinterpolate","text":"","title":"//nth/format:interpolate"},{"location":"format/interpolate/#overview","text":"This target provides added functionality on top of //nth/format by making it possible to specify formatters via interpolation strings . Interpolation strings, as used in the nth library, are strings with some number of matching braces \"{...}\" . Each top-level (non-nested) pair of matching braces constitutes a placeholder into which a value may be formatted. The end result of interpolating will be the interpolation string itself with each placeholder replaced by some formatted object.","title":"Overview"},{"location":"format/interpolate/#basics","text":"The core of the library is the free function-template nth::interpolate . It accepts an nth::interpolation_string template parameter, an nth::io::writer reference, and a number of arguments equal to the number of pairs of matching braces. nth::interpolate<\"'{}' is the Roman numeral symbol for {}.\">( nth::io::stdout_writer, \"IX\", 9); // \"'IX' is the Roman numeral symbol for 9.\" In the example above, the placeholders are simply \"{}\" , but some types support configuration by putting text inside the braces. For example, integers can have an 'x' inside to indicate they should be formatted in base-16. Strings can have a 'q' to indicate that they should be escaped as a quotation. nth::interpolate<\"{} can be written is base-16 as {x}.\">( nth::io::stdout_writer, 17, 17); // 17 can be written is base-16 as 11.\"","title":"Basics"},{"location":"format/interpolate/#builtin-format-options","text":"The following are the interpolation arguments available for builtin types:","title":"Builtin format options"},{"location":"format/interpolate/#bool","text":"{} and {b}: Lower-case. Writes either \"true\" or \"false\"`. { B} : Title-case. Writes either \"True\" or \"False\"`. { B !} : Upper-case. Writes either \"TRUE\" or \"FALSE\"`. { d} : Decimal. Writes either \"1\" or \"0\"`.","title":"bool"},{"location":"format/interpolate/#integral-types","text":"Integral types are anything satisfying the std::integral concept (other than bool ). { d} : Decimal. Writes the number in base-10. { x} : Hexadecimal. Writes the number in base-16.","title":"Integral types"},{"location":"format/interpolate/#string-like","text":"String-like types are anything convertible to std::string_view . {} : Writes the string exactly as-is. { q} : Escaped. Writes the string escaping characters such as \" , and \\ .","title":"String-like"},{"location":"format/interpolate/#custom-interpolation-formatting","text":"By default, the empty interpolation placeholder \"{}\" will format an object with that objects default formatter . However, this behavior is customizable via a FTADLE hook. Specifically, an author of a type T may implement a function template accepting an nth::interpolation_string template argument and an nth::type_tag<T> argument. The function, if provided, will be called with the contents that are between the braces to construct a formatter to be used during interpolation. As an example, struct Person { std::string given_name; std::string family_name; template <nth::interpolation_string S> friend auto NthInterpolateFormatter(nth::type_tag<Person>) { if constexpr (S.empty()) { return full_name_formatter{}; } else if constexpr (S == \"g\") { return given_name_formatter{}; } else if constexpr (S == \"f\") { return family_name_formatter{}; } else { // Checked previously so guaranteed to be false (but dependent on the // template parameter. constexpr bool ValidInterpolationString = S.empty(); static_assert(ValidInterpolationString, \"The interpolation string is invalid. It must be \"{}\", \"{ g}\", or \"{ f}\".); } } }; Now, depending on the interpolation string, a person will be formatted with a full_name_formatter , a given_name_formatter or a family_name_formatter . One might implement those as shown below: struct full_name_formatter { void format(nth::io::writer auto& w, Person const & p) { nth::interpolate<\"{} {}\">(w, p.given_name, p.family_name); } }; struct given_name_formatter { void format(nth::io::writer auto& w, Person const& p) { nth::io::write_text(w, p.given_name); } }; struct family_name_formatter { void format(nth::io::writer auto& w, Person const& p) { nth::io::write_text(w, p.family_name); } };","title":"Custom interpolation formatting."},{"location":"format/interpolate/#escaping","text":"TODO: Escaping has not yet been implemented. At times one may wish for the interpolation string to have a literal '{' character embedded in it which is not treated as the start of a placeholder. To achieve this, one must escape the character by prefixing it with a '`' (and similarly suffixing '}' with '`' ). If one wishes to have a literal backtick character, this also needs to be escaped as \"``\" in the interpolation string. When parsing an interpolation string, the \"max munch\" rule applies except for escaped closing braces (because the escape character follows the character to be escaped). In this case escape tokenization can be thought of as \"max much from the right.\" Alternatively, one could count the number of backtics following the '}' character. The '}' is escaped if and only if there are an odd number of backticks.","title":"Escaping"},{"location":"format/json/","text":"//nth/format:json This target provides a structural formatter that writes objects as valid JSON . Containers such as std::vector or std::array are formatted as JSON arrays. Set-like (unordered) containers are also formatted as JSON arrays. Associative containers such as absl::flat_hash_map or absl::btree_map are formatted as JSON objects.","title":"json"},{"location":"format/json/#nthformatjson","text":"This target provides a structural formatter that writes objects as valid JSON . Containers such as std::vector or std::array are formatted as JSON arrays. Set-like (unordered) containers are also formatted as JSON arrays. Associative containers such as absl::flat_hash_map or absl::btree_map are formatted as JSON objects.","title":"//nth/format:json"},{"location":"io/writer/file/","text":"//nth/io/writer:file Overview This target defines nth::io::file_writer , a type conforming to the nth::io::writer concept, which enables users to write data to a file. The type can be constructed with the static member function try_open , by passing it a nth::io::file_path , which will construct an empty file if it does not already exist, and clear the contents if it does. Calls to write will append to the open file. Example usage bool WriteMessage(nth::io::file_path const & path) { std::optional w = nth::io::file_writer::try_construct(path); if (not w) { return false; } std::string_view message = \"hello,\"; auto result = nth::io::write_text(w, message); return result.written() == message.size(); }","title":"file"},{"location":"io/writer/file/#nthiowriterfile","text":"","title":"//nth/io/writer:file"},{"location":"io/writer/file/#overview","text":"This target defines nth::io::file_writer , a type conforming to the nth::io::writer concept, which enables users to write data to a file. The type can be constructed with the static member function try_open , by passing it a nth::io::file_path , which will construct an empty file if it does not already exist, and clear the contents if it does. Calls to write will append to the open file.","title":"Overview"},{"location":"io/writer/file/#example-usage","text":"bool WriteMessage(nth::io::file_path const & path) { std::optional w = nth::io::file_writer::try_construct(path); if (not w) { return false; } std::string_view message = \"hello,\"; auto result = nth::io::write_text(w, message); return result.written() == message.size(); }","title":"Example usage"},{"location":"io/writer/string/","text":"//nth/io/writer:string Overview This target defines nth::io::string_writer , a type conforming to the nth::io::writer concept, which enables users to write data to a string. The type can be constructed with a mutable reference to a std::string . The referenced string must outlive the string_writer . Calls to write will append to the referenced string. Example usage std::string s; nth::io::string_writer w(s); std::string_view message1 = \"hello,\"; auto result1 = nth::io::write_text(w, message1); NTH_EXPECT(result1.written() == message1.size()); std::string_view message2 = \" world!\"; auto result2 = nth::io::write_text(w, message1); NTH_EXPECT(result2.written() == message2.size()); NTH_EXPECT(s == \"hello, world!\");","title":"string"},{"location":"io/writer/string/#nthiowriterstring","text":"","title":"//nth/io/writer:string"},{"location":"io/writer/string/#overview","text":"This target defines nth::io::string_writer , a type conforming to the nth::io::writer concept, which enables users to write data to a string. The type can be constructed with a mutable reference to a std::string . The referenced string must outlive the string_writer . Calls to write will append to the referenced string.","title":"Overview"},{"location":"io/writer/string/#example-usage","text":"std::string s; nth::io::string_writer w(s); std::string_view message1 = \"hello,\"; auto result1 = nth::io::write_text(w, message1); NTH_EXPECT(result1.written() == message1.size()); std::string_view message2 = \" world!\"; auto result2 = nth::io::write_text(w, message1); NTH_EXPECT(result2.written() == message2.size()); NTH_EXPECT(s == \"hello, world!\");","title":"Example usage"},{"location":"io/writer/writer/","text":"//nth/io/writer Overview This target defines concepts related to writing data in a serialized format. In particular, it defines the nth::io::writer and nth::io::write_result_type concepts. Writers are fundamental to much of nth 's design, including formatting and logging . As writers abstract the writing of both data (to be serialized) and text (to be logged). One might expect a writer to accept a std::string_view but this is fundamentally the wrong type for such a generic interface. Instead, a writer traffics in std::span<std::byte const> . To address this common need, this header also provides a write_text free function, accepting a writer reference and a std::string_view , which converts the std::string_view to a span of bytes and writes the result. Alternatively one may produce a std::span<std::byte const> viewing the bytes of an object via nth::bytes , or view a sequence of bytes represented by an object (such as std::string or std::string_view via nth::byte_range . Because writing data may not succeed, we must also represent the notion of a \"write result.\" This is formalized via the nth::io::write_result_type concept. The writer concept Formally, writer is a concept requiring the type W to contain a write member function that can be invoked with a std::span<std::byte const> . The function is responsible for writing the span of bytes in accordance with how the type W defines \"write.\" The function must return a nth::io::write_result<W> indicating how many bytes were written. For an argument byte_span producing a returned result of result , result.written() must be greater than or equal to zero, result.written() must be less than or equal to byte_span.size() . Callers may interpret result.written() == byte_span.size() as a successful write, result.written() == 0 as a failure, and all other possibilities as partial success. The write_result_type concept The type returned by a call to write on a writer must be something adhering to nth::io::write_result_type . Types adhere to this concept provided they have a written const member function taking no arguments and returning some integral type. The returned value represents the number of bytes written by a call to write . Write result customization. By default, a writer 's associated write result type is nth::io::basic_write_result . This is a minimal, type adhering to the write_result_type concept, outlined here: struct basic_write_result { explicit constexpr basic_write_result(size_t n); [[nodiscard]] constexpr size_t written() const; private: // ... }; Type authors may customize their associated write result type by providing a nested type name nth_write_result_type . This type must be adhere to the write_result_type concept and will be used as the associated write result type. One can query the write result for a writer type W via nth::io::write_result<W> . Examples There are two builtin nth::io::writers of note: nth::io::string_writer , for which calls to write append data to a std::string , and nth::io::file_writer , for which calls to write write the data to a file.","title":"writer"},{"location":"io/writer/writer/#nthiowriter","text":"","title":"//nth/io/writer"},{"location":"io/writer/writer/#overview","text":"This target defines concepts related to writing data in a serialized format. In particular, it defines the nth::io::writer and nth::io::write_result_type concepts. Writers are fundamental to much of nth 's design, including formatting and logging . As writers abstract the writing of both data (to be serialized) and text (to be logged). One might expect a writer to accept a std::string_view but this is fundamentally the wrong type for such a generic interface. Instead, a writer traffics in std::span<std::byte const> . To address this common need, this header also provides a write_text free function, accepting a writer reference and a std::string_view , which converts the std::string_view to a span of bytes and writes the result. Alternatively one may produce a std::span<std::byte const> viewing the bytes of an object via nth::bytes , or view a sequence of bytes represented by an object (such as std::string or std::string_view via nth::byte_range . Because writing data may not succeed, we must also represent the notion of a \"write result.\" This is formalized via the nth::io::write_result_type concept.","title":"Overview"},{"location":"io/writer/writer/#the-writer-concept","text":"Formally, writer is a concept requiring the type W to contain a write member function that can be invoked with a std::span<std::byte const> . The function is responsible for writing the span of bytes in accordance with how the type W defines \"write.\" The function must return a nth::io::write_result<W> indicating how many bytes were written. For an argument byte_span producing a returned result of result , result.written() must be greater than or equal to zero, result.written() must be less than or equal to byte_span.size() . Callers may interpret result.written() == byte_span.size() as a successful write, result.written() == 0 as a failure, and all other possibilities as partial success.","title":"The writer concept"},{"location":"io/writer/writer/#the-write_result_type-concept","text":"The type returned by a call to write on a writer must be something adhering to nth::io::write_result_type . Types adhere to this concept provided they have a written const member function taking no arguments and returning some integral type. The returned value represents the number of bytes written by a call to write .","title":"The write_result_type concept"},{"location":"io/writer/writer/#write-result-customization","text":"By default, a writer 's associated write result type is nth::io::basic_write_result . This is a minimal, type adhering to the write_result_type concept, outlined here: struct basic_write_result { explicit constexpr basic_write_result(size_t n); [[nodiscard]] constexpr size_t written() const; private: // ... }; Type authors may customize their associated write result type by providing a nested type name nth_write_result_type . This type must be adhere to the write_result_type concept and will be used as the associated write result type. One can query the write result for a writer type W via nth::io::write_result<W> .","title":"Write result customization."},{"location":"io/writer/writer/#examples","text":"There are two builtin nth::io::writers of note: nth::io::string_writer , for which calls to write append data to a std::string , and nth::io::file_writer , for which calls to write write the data to a file.","title":"Examples"},{"location":"process/env/","text":"//nth/process:env This target provides a mechanism to safely read and write environment variables. The function nth::env::load returns the value of the enivronment variable if it is set and returns std::nullopt otherwise. The nth::env::store overload set sets, unsets or resets an environment variable. Calls to nth::env::load and nth::env::store are thread-safe (they may be called without external synchronization). Notably this is not true of std::getenv and ::setenv which manipulate globals without synchronization. It is imporatnt to note that the thread-safety does not extend to std::getenv or ::setenv . If any of these functions are also invoked without synchronization against nth::env::load and nth::env::store , the behavior is undefined.","title":"env"},{"location":"process/env/#nthprocessenv","text":"This target provides a mechanism to safely read and write environment variables. The function nth::env::load returns the value of the enivronment variable if it is set and returns std::nullopt otherwise. The nth::env::store overload set sets, unsets or resets an environment variable. Calls to nth::env::load and nth::env::store are thread-safe (they may be called without external synchronization). Notably this is not true of std::getenv and ::setenv which manipulate globals without synchronization. It is imporatnt to note that the thread-safety does not extend to std::getenv or ::setenv . If any of these functions are also invoked without synchronization against nth::env::load and nth::env::store , the behavior is undefined.","title":"//nth/process:env"},{"location":"types/structure/","text":"//nth/types:structure Overview This target provides an enum nth::structure whose fields describe classifications of types. This classification can be used as a mechanism for traversing the structure of a type. Different use-cases may have different opinions about the structure of types (e.g., one may wish to think of a std::string as primitive, an object type, or a character-sequence depending on the context), so there is no prescribed assignment of an nth::structure to any types. nth::structure primitive : A tag associated with types that are considered \"primitive,\" or atomic. This association may be context-dependent. While std::string is not a builtin primitive type in the C++ language, strings are considered primitive for languages like JSON or YAML. associative : A tag associated with types that represent values keyed on other values. std::map , and absl::flat_hash_map are common examples of templates representing associative structures. Note that C++ texts often refer to std::set as an \"associative container,\" but the intended meaning here does not include std::set as associative because it does not associate keys with values. variant : A tag associated with types that hold exactly one value of a type not known statically. The set of possible types held by the object need not be restricted in any way. In other words, while std::variant is a classic example of such a type in C++, std::any would also be such a type. sequence : A tag associated with types holding sequences of data. This tag does not make any claims about whether data may be repeated, the storage layout, computational costs (or even feasibility) of insertion, deletion, modification, etc. This tag represents a categorization of types for which data is associated to some number of consecutive nonnegative integers starting at 0. object : A tag associated with types that are \"struct-like\" in the sense that they are associative but the keys are fixed. entry : A tag associated with elements in a sequnece. Structurally, a sequence contains an ordered collection of entries, each of which may have its own structure. This tag will never be directly associated with a type, but can be useful when traversing the sturcture of a sequence. key : A tag associated with the key in an associative or object structure. This tag will never be directly associated with a type, but can be useful when traversing the structure of an associative or object type. value : A tag associated with the value in an associative or object structure. This tag will never be directly associated with a type, but can be useful when traversing the structure of an associative or object type. unknown : A default tag associated with types whose structure is unspecified via the mechanisms provided below and cannot be deduced.","title":"structure"},{"location":"types/structure/#nthtypesstructure","text":"","title":"//nth/types:structure"},{"location":"types/structure/#overview","text":"This target provides an enum nth::structure whose fields describe classifications of types. This classification can be used as a mechanism for traversing the structure of a type. Different use-cases may have different opinions about the structure of types (e.g., one may wish to think of a std::string as primitive, an object type, or a character-sequence depending on the context), so there is no prescribed assignment of an nth::structure to any types.","title":"Overview"},{"location":"types/structure/#nthstructure","text":"primitive : A tag associated with types that are considered \"primitive,\" or atomic. This association may be context-dependent. While std::string is not a builtin primitive type in the C++ language, strings are considered primitive for languages like JSON or YAML. associative : A tag associated with types that represent values keyed on other values. std::map , and absl::flat_hash_map are common examples of templates representing associative structures. Note that C++ texts often refer to std::set as an \"associative container,\" but the intended meaning here does not include std::set as associative because it does not associate keys with values. variant : A tag associated with types that hold exactly one value of a type not known statically. The set of possible types held by the object need not be restricted in any way. In other words, while std::variant is a classic example of such a type in C++, std::any would also be such a type. sequence : A tag associated with types holding sequences of data. This tag does not make any claims about whether data may be repeated, the storage layout, computational costs (or even feasibility) of insertion, deletion, modification, etc. This tag represents a categorization of types for which data is associated to some number of consecutive nonnegative integers starting at 0. object : A tag associated with types that are \"struct-like\" in the sense that they are associative but the keys are fixed. entry : A tag associated with elements in a sequnece. Structurally, a sequence contains an ordered collection of entries, each of which may have its own structure. This tag will never be directly associated with a type, but can be useful when traversing the sturcture of a sequence. key : A tag associated with the key in an associative or object structure. This tag will never be directly associated with a type, but can be useful when traversing the structure of an associative or object type. value : A tag associated with the value in an associative or object structure. This tag will never be directly associated with a type, but can be useful when traversing the structure of an associative or object type. unknown : A default tag associated with types whose structure is unspecified via the mechanisms provided below and cannot be deduced.","title":"nth::structure"}]}