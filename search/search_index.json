{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NTH A collection of libraries I find generally useful. Broadly speaking, nth aims at providing high-quality, highly-customizable libraries to be used across a broad number of applications. Some of these libraries are additive to the C++ standard library, while others are replacements/alternatives. Building from source nth is a collection of C++23 libraries, and relies heavily on Bazel for building and testing. You will need a C++23-compliant compiler and a relatively recent copy of Bazel . Specifically, Bazel version 6.3.2 or greater Clang 18.0.0 The nth libraries are intended to be used from your C++ code and always built from source. For this reason, we do not provide any installation or setup process. If you would like to download and play around with the examples, they can be built via these commands: $ git clone https://github.com/asoffer/nth.git $ cd nth $ bazel test ... If you would like to include nth in your own Bazel-based project, you can consume it as a Bazel module . I host a Bazel repository and update it somewhat regularly. You are of course always welcome to host your own Bazel repository pointing to the source on this github repository. Why is it called nth ? Mostly because I use a Dvorak keyboard layout, and those three characters in that order are particularly easy to type. It also has the accurate connotation that this is yet another kitchen sink utility library, but I didn't realize that until first mashing on the keyboard.","title":"Home"},{"location":"#nth","text":"A collection of libraries I find generally useful. Broadly speaking, nth aims at providing high-quality, highly-customizable libraries to be used across a broad number of applications. Some of these libraries are additive to the C++ standard library, while others are replacements/alternatives.","title":"NTH"},{"location":"#building-from-source","text":"nth is a collection of C++23 libraries, and relies heavily on Bazel for building and testing. You will need a C++23-compliant compiler and a relatively recent copy of Bazel . Specifically, Bazel version 6.3.2 or greater Clang 18.0.0 The nth libraries are intended to be used from your C++ code and always built from source. For this reason, we do not provide any installation or setup process. If you would like to download and play around with the examples, they can be built via these commands: $ git clone https://github.com/asoffer/nth.git $ cd nth $ bazel test ... If you would like to include nth in your own Bazel-based project, you can consume it as a Bazel module . I host a Bazel repository and update it somewhat regularly. You are of course always welcome to host your own Bazel repository pointing to the source on this github repository.","title":"Building from source"},{"location":"#why-is-it-called-nth","text":"Mostly because I use a Dvorak keyboard layout, and those three characters in that order are particularly easy to type. It also has the accurate connotation that this is yet another kitchen sink utility library, but I didn't realize that until first mashing on the keyboard.","title":"Why is it called nth?"},{"location":"base/attributes/","text":"//nth/base:attributes Overview Defines macros which wrap compiler-specific attributes and gives them a consistent API. One may query whether an attribute is supported via NTH_SUPPORTS_ATTRIBUTE(<attribute_name>) , and use the attribute via NTH_ATTRIBUTE(<attribute_name>) . A compilation error will be reported for any unsupported attribute. One may also use NTH_ATTRIBUTE_TRY(<attribute_name>) which will expand to the appropriate attribute if it is supported and nothing otherwise. Available attributes Note that not all of these attributes are available on all platforms. lifetimebound Defines an attribute consistent with the proposed wg21.link/p0936r0. When attached to a function parameter, indicates that the return value may reference the object bound to the attributed function parameter. weak Defines an attribute which may be used to mark symbol declarations and definitions as 'weak'. All unattributed symbols are implicitly declared strong. During linking, if any strong symbol of the same name exists all weak symbols will be ignored. Beyond this rule, the one-definition rule still applies: There must be either exactly one strong symbol definition, or no strong symbol definitions and one weak symbol definition. tailcall Defines an attribute indicating that the annotated return statement must be tail-call optimized. Use of this attribute is intended for situations where tail-call optimization is a requirement for correctness, rather than an optimization. As such, no fallback implementation is supported if the compiler does not support it. inline_always Defines an attribute indicating that the annotated function must be inlined by the compiler. Note that this attribute refers to how the compiler generates executable code, not the inline attribute in C++. inline_never Defines an attribute indicating that the annotated function must not be inlined by the compiler. Note that this attribute refers to how the compiler generates executable code, not the inline attribute in C++. trivial_abi Defines an attribute indicating that the annotated struct is trivial for the purposes of calls, indicating that it can be passed in registers.","title":"<code>:attributes</code>"},{"location":"base/attributes/#nthbaseattributes","text":"","title":"//nth/base:attributes"},{"location":"base/attributes/#overview","text":"Defines macros which wrap compiler-specific attributes and gives them a consistent API. One may query whether an attribute is supported via NTH_SUPPORTS_ATTRIBUTE(<attribute_name>) , and use the attribute via NTH_ATTRIBUTE(<attribute_name>) . A compilation error will be reported for any unsupported attribute. One may also use NTH_ATTRIBUTE_TRY(<attribute_name>) which will expand to the appropriate attribute if it is supported and nothing otherwise.","title":"Overview"},{"location":"base/attributes/#available-attributes","text":"Note that not all of these attributes are available on all platforms.","title":"Available attributes"},{"location":"base/attributes/#lifetimebound","text":"Defines an attribute consistent with the proposed wg21.link/p0936r0. When attached to a function parameter, indicates that the return value may reference the object bound to the attributed function parameter.","title":"lifetimebound"},{"location":"base/attributes/#weak","text":"Defines an attribute which may be used to mark symbol declarations and definitions as 'weak'. All unattributed symbols are implicitly declared strong. During linking, if any strong symbol of the same name exists all weak symbols will be ignored. Beyond this rule, the one-definition rule still applies: There must be either exactly one strong symbol definition, or no strong symbol definitions and one weak symbol definition.","title":"weak"},{"location":"base/attributes/#tailcall","text":"Defines an attribute indicating that the annotated return statement must be tail-call optimized. Use of this attribute is intended for situations where tail-call optimization is a requirement for correctness, rather than an optimization. As such, no fallback implementation is supported if the compiler does not support it.","title":"tailcall"},{"location":"base/attributes/#inline_always","text":"Defines an attribute indicating that the annotated function must be inlined by the compiler. Note that this attribute refers to how the compiler generates executable code, not the inline attribute in C++.","title":"inline_always"},{"location":"base/attributes/#inline_never","text":"Defines an attribute indicating that the annotated function must not be inlined by the compiler. Note that this attribute refers to how the compiler generates executable code, not the inline attribute in C++.","title":"inline_never"},{"location":"base/attributes/#trivial_abi","text":"Defines an attribute indicating that the annotated struct is trivial for the purposes of calls, indicating that it can be passed in registers.","title":"trivial_abi"},{"location":"base/configuration/","text":"//nth/base:configuration Provides a queryable interface to some build configuration information. NTH_RTTI_ENABLED A macro which expands to true if runtime type information is available and to false otherwise. NTH_BUILD_MODE A function-like macro that expands to either true or false , to indicate that a particular build mode is specified. Build modes can be optimize : Indicates that runtime execution speed is the primary concern. Other potential priorities such as debuggability or safety are considered less imporant. harden : Indicates that the primary concern for the executable is runtime execution speed, but that we are willing to tolerate a small performance loss for particularly important safety features. Other priorities, such as executable size or debuggability are not considered priorities. debug : Indicates that the primary concern for this executable is debuggability, and that other potential priorities (for example executable size, or runtime execution speed) are considered less important. fast : Indicates that the primary concern for this executable is compilation time, and that other priorities such as runtime execution speed, debuggability, or safety, may be sacrificed in order to compile the executable faster. A build mode may only be specified on the commandline by defining the NTH_COMMANDLINE_BUILD_MODE macro to one of these identifiers. If no build mode is specified, the library will attempt to detect an appropriate mode, but without any guarantees. The chosen build mode will be encoded in the constexpr variable nth::build_mode , whose type is given by enum class build { optimize, harden, debug, fast, };","title":"<code>:configuration</code>"},{"location":"base/configuration/#nthbaseconfiguration","text":"Provides a queryable interface to some build configuration information.","title":"//nth/base:configuration"},{"location":"base/configuration/#nth_rtti_enabled","text":"A macro which expands to true if runtime type information is available and to false otherwise.","title":"NTH_RTTI_ENABLED"},{"location":"base/configuration/#nth_build_mode","text":"A function-like macro that expands to either true or false , to indicate that a particular build mode is specified. Build modes can be optimize : Indicates that runtime execution speed is the primary concern. Other potential priorities such as debuggability or safety are considered less imporant. harden : Indicates that the primary concern for the executable is runtime execution speed, but that we are willing to tolerate a small performance loss for particularly important safety features. Other priorities, such as executable size or debuggability are not considered priorities. debug : Indicates that the primary concern for this executable is debuggability, and that other potential priorities (for example executable size, or runtime execution speed) are considered less important. fast : Indicates that the primary concern for this executable is compilation time, and that other priorities such as runtime execution speed, debuggability, or safety, may be sacrificed in order to compile the executable faster. A build mode may only be specified on the commandline by defining the NTH_COMMANDLINE_BUILD_MODE macro to one of these identifiers. If no build mode is specified, the library will attempt to detect an appropriate mode, but without any guarantees. The chosen build mode will be encoded in the constexpr variable nth::build_mode , whose type is given by enum class build { optimize, harden, debug, fast, };","title":"NTH_BUILD_MODE"},{"location":"base/core/","text":"//nth/base:core Provides two macros NTH_MOVE and NTH_FORWARD which are replacements for std::move and std::forward respectively. In large code bases the extra cost of compiling these function templates and inlining them can have noticeable affect on compilation times. These macros are equivalent implementations removing that cost.","title":"<code>:core</code>"},{"location":"base/core/#nthbasecore","text":"Provides two macros NTH_MOVE and NTH_FORWARD which are replacements for std::move and std::forward respectively. In large code bases the extra cost of compiling these function templates and inlining them can have noticeable affect on compilation times. These macros are equivalent implementations removing that cost.","title":"//nth/base:core"},{"location":"base/indestructible/","text":"//nth/base:indestructible An nth::indestructible<T> is a wrapper around an object of type T which does not invoke the destructor of T when it is destroyed. The primary motivation for such a type is for non-trivial static globals; such types frequently do not need to have their destructors run (as resources are returned to the operating system on exit). Moreover, running these destructors is typically fraught, if references to these object are held by multiple threads.","title":"<code>:indestructible</code>"},{"location":"base/indestructible/#nthbaseindestructible","text":"An nth::indestructible<T> is a wrapper around an object of type T which does not invoke the destructor of T when it is destroyed. The primary motivation for such a type is for non-trivial static globals; such types frequently do not need to have their destructors run (as resources are returned to the operating system on exit). Moreover, running these destructors is typically fraught, if references to these object are held by multiple threads.","title":"//nth/base:indestructible"},{"location":"base/section/","text":"//nth/base:section Provides an API for defining sections in a binary and placing symbols in those sections. A section may be declared with NTH_DECLARE_SECTION(my_section_name, some_type) , indicating that the section is named \"my_section_name\" and that all elements in that section will have type some_type . Sections holding heterogeneously-typed objects are not supported. One may query this element-type of a section via nth::section_type<\"my_section_name\"> . Once a section has been declared, one may place objects in the section by prefixing their declaration with NTH_PLACE_IN_SECTION(my_section_name) . The expression nth::section<\"my_section_name\"> provides begin and end member functions and may be iterated over via a range-for loop.","title":"<code>:section</code>"},{"location":"base/section/#nthbasesection","text":"Provides an API for defining sections in a binary and placing symbols in those sections. A section may be declared with NTH_DECLARE_SECTION(my_section_name, some_type) , indicating that the section is named \"my_section_name\" and that all elements in that section will have type some_type . Sections holding heterogeneously-typed objects are not supported. One may query this element-type of a section via nth::section_type<\"my_section_name\"> . Once a section has been declared, one may place objects in the section by prefixing their declaration with NTH_PLACE_IN_SECTION(my_section_name) . The expression nth::section<\"my_section_name\"> provides begin and end member functions and may be iterated over via a range-for loop.","title":"//nth/base:section"}]}